
% !TEX root = Entwurf_goApp.tex

\section{Entwurfsentscheidungen}
	\subsection{Einleitung}
	Das folgende Dokument beschreibt den Entwurf der goApp und ist nach dem Prinzip top-down aufgebaut.
	Zunächst werden die Entscheidungen bezüglich der Architektur und welche Entwurfsmuster zum Einsatz kommen erläutert.
	Darauf folgen Beschreibungen zu jedem Package und schlussendlich wird auf jede Klasse im einzelnen eingegangen.
	Im Kapitel Sequenzdiagramme werden interne Abläufe graphisch dargestellt und sollen das Zusammenspiel unserer Komponenten verdeutlichen. 
	Im Anhang findet sich ein großformatiges Diagramm mit allen Klassen.
	\subsection{Architektur}
	Die Architektur der goApp ist die Client-Server Architektur. Diese zeichnet sich dadurch aus, das ein passiver Server Anfragen der aktiven Clients entgegennimmt, bearbeitet und eine Antwort zurück übermittelt. Die Architektur bietet sich in diesem Fall an, da die goApp mehrere Nutzer hat und diese gleichzeitig auf die selben Daten und Services zugreifen können müssen. 
	Ein Client ist in diesem Fall ein Androidgerät und der Server ein auf Linux basierender Webserver.
	Der Entwurf verwirklicht die Client-Server-Architektur dadurch, dass der Client Http-Anfragen an den Server schickt. Der Server stellt auf Anfrage den Zugriff auf entsprechende Nutzer, Gruppen und Termin Daten zur Verfügung. Diese Daten sind in der Datenbank auf dem Server gespeichert, zusätzlich zur Bereitstellung von Daten können diese Daten über Anfragen des Clients auch geändert werden. Zudem stellt der Server noch die Berechnung des Gruppenmittelpunktes in Form eines Clustering-Algorithmus zur Verfügung. 
	 
	3-Schichten?
	
	
	\subsection{Paketstruktur}
	 \includegraphics[width=1.1\textwidth]{Packages.png}

	\subsection{Server \& Client Kommunikation}
	Wir verwenden JavaScript Object Notation Remote Procedure Call (kurz: JSON-RPC) für die Kommunikation zwischen den Clienten und dem Server.
	Ein JSON-RPC-Call besteht aus einem JSON-Objekt, das vom Client an einen Server geschickt wird und wird auch mit einem JSON-Objekt beantwortet.
	Durch die Nutzung von JSON-RPC versprechen wir uns eine flexible aber vor allem eine einfache Kommunikation, welche wir genau auf unsere 		Anforderungen anpassen können.
Durch das explizite angeben der Methode in der Anfrage ist man frei bei der Wahl der Methoden für ein Servlet. Bei alternativen wie z.B. REST sind die Methoden eines Servlets gebunden an die Methoden (GET, POST, PUT, Delete...) des HTTP-Protkolls. Deshalb ist man nicht so frei bei der Gestaltung der Servlets und ist gezwungen seine Methoden anzupassen.
	
	\subsection{Server}
	\subsubsection{Model}
Im Model werden Benutzer, Gruppen und Events direkt aus der Realität auf die entsprechende Klasse abgebildet und zusätzlich existieren Klassen die den Standort und Gruppenbeitrittsanfragen der Benutzer darstellen.
Ein Benutzer kann Mitglied in bis zu 20 Gruppen sein, und in jeder Gruppe darf es bis zu 50 Mitglieder geben sowie genau einen Gründer. Bevor ein Benutzer Mitglied einer Gruppe werden kann muss eine Beitrittsanfrage erstellt werden.
Pro Benutzer können bis zu 20 Anfragen gleichzeitig existieren, diese werden mit jeweils einer Gruppe assoziiert.
An eine Gruppe können jedoch beliebig viele Anfragen gestellt werden.
Ebenso können in einer Gruppe beliebig viele Events existieren an denen jeweils alle Gruppenmitglieder teilnehmen können.
Damit die Teilnehmer eines Events sich finden können existiert die Location Klasse, eine Location kann entweder genau einem Benutzer oder genau einem Termin zugeordnet sein. 
Eine genaue Beschreibung aller Klassen des Models mitsamt ihren Methoden findet sich im Kapitel 3.1.
-Hier Model Bild einfügen-

	\subsubsection{DatabaseAdapter}
	Die Klassen des Database Adapters sorgen für den Zugriff auf die MySQL Datenbank.
Sie nehmen entweder die Anfragen der Servlets oder des Clustering-Algorithm entgegen, durchsuchen die Datenbank nach den entsprechenden Daten und geben die Daten wieder zurück.  
Oder sie speichern die gegebenen Daten auf der Datenbank.
TODO: Hier bitte noch etwas genauer beschreiben(Eva) aber ich weiß immernoch nicht wie genau das Funktioniert :D
Eine genaue Beschreibung aller Klassen des DatabaseAdapters mitsamt ihren Methoden findet sich im Kapitel 3.2.
-Hier database.management Bild einfügen-

	\subsubsection{Database}
	In der Datenbank werden für alle Elemente und Objekte die entsprechenden Daten gespeichert und bei Bedarf ausgelesen. Hierzu wird für jede Klasse des Models sowie für bestimmte Beziehungen eine Tabelle angelegt.
Identifiziert werden die jeweiligen Objekte durch eine eindeutige ID welche bei der Erstellung des Eintrags vergeben wird.
Für Benutzer kommt diese ID von Google für die anderen Klassen wird die ID direkt von unserem Server vergeben.
TODO: Hier vielleicht noch ein UML-Diagramm erstellen auf dem alle Tabellen sind die wir speichern werden (also auch die Zwischentabellen) und was jeweils gespeichert wird.

	\subsubsection{Clusteringalgorithmus}
	Das Clusteralgorithmuspaket gruppiert Standorte und kann den Mittelpunkt mehrerer Standorte berechnen. Wir haben uns dabei dazu entschieden das Entwutfsmuster Strategie zu verwenden um es zu ermöglichen die Implementierung der Clusteranalyse, sowie der Mittelpunktberechnung abzukapseln und somit für die jeweiligen Bedürfnisse austauschbar zu machen. Einzelne Klassen aus dem Clusteralgorithmuspaket sind aus der Apache Commons Mathematics Bibliothek und müssen somit nicht mehr von uns implementiert werden. Wir haben uns dazu entschieden Teile dieser Bibliothek zu verwendet, da sie unter der Apache Lizens steht, gut getestet ist und perfekt zu unserem Projekt passt. Außerdem soll unser Projekt einen Mehrwert generieren und nicht darin bestehen vorhandene Software nachzubauen. Das Clusteralgorithmuspaket holt sich die benötigten Daten selbständig von der Datenbank und werden nicht von dem Servelet an den Algortihmus gegeben, um die benötigten Daten nur von dem Algorithmus abhängig zu machen und so Austauschbarkeit zu unterstützen.

	\subsubsection{Servlets}
	Die Servlets nehmen die Anfragen der Clienten entgegen. Diese ist immer ein JSON-String welcher von den Servlets ausgelesen und danach entsprechend behandelt wird. Die Servlets leiten die erhaltenden Anfragen entweder an die Datenbankverwaltung oder an den Algorithmus weiter und schicken das Ergebnis an den Clienten.
Die Servlets fungieren so als Schnittstelle zwischen den Anfragen des Clienten und der eigentlichen Arbeit die auf dem Server vollbracht wird. 
Die Servlets sind in ihren Aufgabenbereichen unabhängig von einander und intuitiv auf das Modell angepasst, so gibt es ein Servlet was alle Anfragen bezüglich eines Events beantwortet und ein weiteres welches sich um die Handhabung der Gruppenbeitrittsanfragen kümmert.
Die Servlets sind auf die Services des Clienten zugeschnitten, ein Servlet beantwortet also nur Anfragen von genau einem Service.
Für eine weitere Funktionalität kann also einfach ein neuer Service mit einem neuem Servlet unabhängig von allen anderen erstellt werden was den Entwurf einfach erweiterbar macht.   
-Hier servlet Bild einfügen-

	\subsection{Client}
	Der Client implementiert das Entwurfsmuster Model-View-Controller was unseren Entwurf flexibel und austauschbar macht.
	\subsubsection{Services}
	Die Services sind der Controller des Clienten und damit für die Steuerung zuständig. Hauptaufgabe ist es die Kommunikation zwischen der View und dem Server zu gewährleisten, aber auch Hintergrundprozesse anderer Art wie das erstellen eines Timers gehören in ihren Aufgabenbereich.
Sie sind wie die Servlets so entworfen dass jeder Service seinen eigenen Aufgabenbereich übernimmt.
Von unserer App werden folgende Services implementiert:

-Hier services Bild einfügen-

	\subsubsection{Activities}
	Alle Activities setzten sich aus XML-Dateien zusammen und bilden gemeinsam die View des Users.
Sie nehmen als erstes Benutzerinteraktionen entgegen, leiten diese an den entsprechenden Service weiter und geben dem User entsprechendes Feedback.
	--Hier view Bild einfügen-
	\subsubsection{Model}
Das Model versucht die Realität auf die Daten des Servers und der Applikation abzubilden und ist von dem Controller und der View unabhängig. Das Modell ist das zu beobachtende Subjekt nach dem Entwurfsmuster "Beobachter".
%TODO Implementieren wir wirklich das Entwurfsmuster Beobachter?
Das Model auf dem Client entspricht dem Model des Servers.
	\subsubsection{ServerAdapter}
	Der ServerAdapter bildet die Schnittstelle zwischen dem Server und dem Client. Die Services schicken Anfragen an den ServerAdapter, welcher diese über eine HTTP-Verbindung an die entsprechenden Servlets des Servers weiterleitet und dessen Antwort wieder an den Service zurückgibt.


	\newpage
